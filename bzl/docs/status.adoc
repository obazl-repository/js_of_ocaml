= OBazl Js_of_ocaml Status

As of Monday 26 September 2022.

For the most part, the Bazel code generated by `@obazl//convert works.
Targets build and executable targets run. But there are some
execptions, some of which will go away with more work on the
converter, and some of which will always require manual intervention,
usually because the code involved implicitly depends on some dune
feature, such as the launch location of tools. All are described
below.

Library code and executables build and run.

*Tests*

Some build and run, some build but don't run, some don't build. "Don't
build" means the converter cannot currently generate correct code; it
does not mean that OBazl cannot handle the build. In all cases it is
possible to correct the Bazel code by hand to make it work.

Inline tests and expect tests build but do not yet run. Emitting the
code needed to run such tests is still a work-in-progress. Ditto for
rules that run `diff`.

Tests/rules that use node to run js "executables" produced by jsoo are
not yet converted. They build though, and can be run with `node` on
the command line; they just can't be run using `bazel run`.

To work with Bazel test facilities, test executables must return a
non-zero exit code on failure; at least one of the Jsoo tests fails to
do this.

Many of the tests are implemented as dune 'executable' stanzas rather
than 'test' stanzas. We can run them, but ideally these should
translate into `ocaml_test` or `jsoo_test` targets, so we can run them
using `bazel test`. But the conversion tool is not quite clever enough
to automatically detect which dune `executbles` should translate to
tests. This is work-in-progress.

Dune 'rule' stanzas do not have names. To translate them to Bazel
targets, OBazl must decide on a name. Sometimes that's easy,
sometimes not.

The converter can be configured to emit `rules_jsoo` code and
`rules_js` code. WIP. To be added: emission of `rules_swc` and
`rules_closure` code.

== benchmarks

Executables build but when run they report missing config file. The
executables (`report.ml`, `run.ml`) take a `-config` arg but the dune
file does not use it, so they default to `report.config` and
`run.config`, respectively.

To run the benchmarks under dune evidently requires `cd benchmarks &&
make`; the main Makefile does not have a `benchmarks` target. This
builds the stuff in `benchmarks/sources` and runs the executables
(which takes forever). This uses `dune exec` to run the executables
but build program itself is written in `benchmarks/Makefile`.

IMPORTANT: The benchmark code runs either node or spidermonkey from
the sys environment.  See `run.config`.

To make this work under Bazel we would need to translate the Makefile
by hand. To fully bazelize it we would also need to change the sources
to remove the dependency on a system-installed runner (node or
spidermonkey). We could do this by using a CLI option `--interpreter`
(or something) instead of reading a config file. However we need to
pass both interpreter name ('node') and path (`/usr/bin/node`).

Alternatively, we can write the `run.config` file at build time, using
info from the selected Js toolchain.

Or, we can find a way to use rules_js to run the benchmarks.
Effectively replacing `run.ml`.


== compiler

=== compiler/bin-js_of_ocaml

Target `compiler/bin-js_of_ocaml:js_of_ocaml.exe` corresponds to dune
executable `(name js_of_ocaml)`.  Builds and runs.

Target `compiler/bin-js_of_ocaml:runtime.js` runs jsoo with subcommand
`print-standard-runtime` to generate `runtime.js`. Builds and runs.

The `rule` stanzas build manpages, which we're ignoring for now.

The `install` rule installs the manpages. Ignoring.

The remaining `install` rule installs `runtime.js` into
`@js_of_ocaml-compiler/lib`. Ignoring for now.

=== compiler/bin-jsoo_minify

Target: `compiler/bin-jsoo_minify:jsoo_minify.exe` corresponds to dune
executable `jsoo_minify`. Builds and runs.

The remaining rules build and install manpages.

=== compiler/lib

Target `compiler/lib:js_of_ocaml_compiler`, dune library of same name.
Builds and functions.

Depends on `ocaml_ocamllex` and `menhir` targets, which work.

Dune rule with target `compiler_version.ml` translates to `copy_file` rule.


=== compiler/lib-cmdline

Target `compiler/lib-cmdline:jsoo_cmdline`.  Works.

=== compiler/lib-findlib-support

Not needed in OBazl but does build.

=== compiler/lib-runtime-files

Target `compiler/lib-runtime-files:js_of_ocaml_compiler_runtime_files` builds.


=== compiler/ppx

Target `compiler/ppx:ppx_optcomp_light` builds.

=== compiler tests
 
* tests-check-prim - the executables build and run but they're not really tests, they just run the `check-runtime` subcommand of jsoo and dump the results to a file.

* tests-compiler - builds libraries (that is, archives) with `inline_tests` enabled. These build, but we do not yet have the executable needed to run the tests.

* tests-dynlink - the `main.exe` target builds and runs but prints
  `Unimplemented Javascript primitive caml_js_expr!`.

* tests-io - disabled for now (see `.config/miblrc`). The dune file
  contains code that the Scheme reader cannot handle, e.g `(run printf
  "echo \226\152\160")`. The Scheme reader does not like those
  unescaped backslashes. I believe it will be possible to write an
  error handler that will take care of this.

* tests-jsoo

* tests-num - main.exe target builds and runs, but the converter chokes on one rule stanza, so we did not convert that. Under research. Also the `diff` rule not tested.

=== compiler/tests-ocaml

* basic-modules: targets `recursive_module_init.exe` and `recursive_module_init.exe.js` build and run.
* lib-atomic:  targets `test_atomic.exe`, `test_atomic.exe.js` build and run
* lib-bigarray: targets `bigarrays.exe`, `bigarrays.exe.js` build and run. The `diff` rules are translated but have not been tested.
* lib-bool: targets test.exe, test.exe.js build and run
* lib-buffer: targets test.exe, test.exe.js build and run
* 

====  tests-re


